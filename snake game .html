<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }

        .game-container {
            text-align: center;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            border: 4px solid #fff;
            border-radius: 10px;
            background: #87CEEB;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .game-info {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            width: 600px;
            font-size: 24px;
            font-weight: bold;
        }

        .score {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .high-score {
            background: rgba(255, 215, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .instructions {
            margin-top: 20px;
            font-size: 18px;
            opacity: 0.9;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
            border: 3px solid #fff;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .game-over p {
            font-size: 24px;
            margin-bottom: 20px;
        }

        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        .restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üêç Snake Game</h1>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div class="game-info">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="high-score">High Score: <span id="highScore">0</span></div>
        </div>
        <div class="instructions">
            Use arrow keys (‚Üë ‚Üì ‚Üê ‚Üí) to control the snake
        </div>
        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="startGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        // Game constants
        const GRID_SIZE = 20;
        const GRID_WIDTH = canvas.width / GRID_SIZE;
        const GRID_HEIGHT = canvas.height / GRID_SIZE;

        // Game state
        let snake = [{ x: 10, y: 10 }];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = {};
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameRunning = false;
        let gameLoop = null;

        // Set initial high score display
        highScoreElement.textContent = highScore;

        // Generate random food position
        function generateFood() {
            food = {
                x: Math.floor(Math.random() * GRID_WIDTH),
                y: Math.floor(Math.random() * GRID_HEIGHT)
            };
            // Make sure food doesn't spawn on snake
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    generateFood();
                    return;
                }
            }
        }

        // Draw functions
        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, width * GRID_SIZE, height * GRID_SIZE);
        }

        function drawSnake() {
            snake.forEach((segment, index) => {
                if (index === 0) {
                    // Head - different color
                    drawRect(segment.x, segment.y, 1, 1, '#4ade80');
                    // Eyes
                    ctx.fillStyle = '#fff';
                    const eyeSize = 0.15;
                    const eyeOffset = 0.25;
                    if (direction.x === 1) { // Moving right
                        ctx.fillRect((segment.x + 0.7) * GRID_SIZE, (segment.y + eyeOffset) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                        ctx.fillRect((segment.x + 0.7) * GRID_SIZE, (segment.y + 0.6) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                    } else if (direction.x === -1) { // Moving left
                        ctx.fillRect((segment.x + eyeOffset) * GRID_SIZE, (segment.y + eyeOffset) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                        ctx.fillRect((segment.x + eyeOffset) * GRID_SIZE, (segment.y + 0.6) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                    } else if (direction.y === -1) { // Moving up
                        ctx.fillRect((segment.x + eyeOffset) * GRID_SIZE, (segment.y + eyeOffset) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                        ctx.fillRect((segment.x + 0.6) * GRID_SIZE, (segment.y + eyeOffset) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                    } else { // Moving down
                        ctx.fillRect((segment.x + eyeOffset) * GRID_SIZE, (segment.y + 0.7) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                        ctx.fillRect((segment.x + 0.6) * GRID_SIZE, (segment.y + 0.7) * GRID_SIZE, eyeSize * GRID_SIZE, eyeSize * GRID_SIZE);
                    }
                } else {
                    // Body - gradient color
                    const intensity = 1 - (index / snake.length) * 0.3;
                    drawRect(segment.x, segment.y, 1, 1, `rgb(${74 + intensity * 50}, ${222 - intensity * 30}, ${128 - intensity * 20})`);
                }
            });
        }

        function drawFood() {
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(
                (food.x + 0.5) * GRID_SIZE,
                (food.y + 0.5) * GRID_SIZE,
                GRID_SIZE * 0.4,
                0,
                Math.PI * 2
            );
            ctx.fill();
            // Inner highlight
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(
                (food.x + 0.5) * GRID_SIZE - 2,
                (food.y + 0.5) * GRID_SIZE - 2,
                GRID_SIZE * 0.2,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        function drawLandscape() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB'); // Sky blue
            skyGradient.addColorStop(0.5, '#98D8E8');
            skyGradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sun
            const sunGradient = ctx.createRadialGradient(500, 100, 0, 500, 100, 60);
            sunGradient.addColorStop(0, '#FFD700');
            sunGradient.addColorStop(0.7, '#FFA500');
            sunGradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(500, 100, 60, 0, Math.PI * 2);
            ctx.fill();

            // Clouds
            function drawCloud(x, y, size) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
                ctx.arc(x + size * 0.5, y, size * 0.7, 0, Math.PI * 2);
                ctx.arc(x + size, y, size * 0.6, 0, Math.PI * 2);
                ctx.arc(x + size * 0.3, y - size * 0.3, size * 0.5, 0, Math.PI * 2);
                ctx.arc(x + size * 0.7, y - size * 0.3, size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            drawCloud(100, 80, 40);
            drawCloud(200, 120, 35);
            drawCloud(350, 90, 45);
            drawCloud(450, 150, 30);

            // Mountains in the background
            ctx.fillStyle = '#8B7D6B';
            ctx.beginPath();
            ctx.moveTo(0, 400);
            ctx.lineTo(150, 250);
            ctx.lineTo(300, 300);
            ctx.lineTo(450, 200);
            ctx.lineTo(600, 280);
            ctx.lineTo(600, 400);
            ctx.closePath();
            ctx.fill();

            // Mountain highlights
            ctx.fillStyle = '#A0937D';
            ctx.beginPath();
            ctx.moveTo(150, 400);
            ctx.lineTo(150, 250);
            ctx.lineTo(200, 280);
            ctx.lineTo(250, 320);
            ctx.lineTo(300, 300);
            ctx.lineTo(300, 400);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#A0937D';
            ctx.beginPath();
            ctx.moveTo(450, 400);
            ctx.lineTo(450, 200);
            ctx.lineTo(500, 220);
            ctx.lineTo(550, 260);
            ctx.lineTo(600, 280);
            ctx.lineTo(600, 400);
            ctx.closePath();
            ctx.fill();

            // Trees
            function drawTree(x, y, height) {
                // Trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 3, y, 6, height * 0.3);
                
                // Leaves
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(x, y - height * 0.1, height * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x - height * 0.15, y - height * 0.15, height * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + height * 0.15, y - height * 0.15, height * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            drawTree(80, 380, 40);
            drawTree(120, 390, 35);
            drawTree(160, 385, 45);
            drawTree(200, 395, 30);
            drawTree(520, 385, 40);
            drawTree(560, 390, 35);

            // Grass ground
            const grassGradient = ctx.createLinearGradient(0, 450, 0, canvas.height);
            grassGradient.addColorStop(0, '#90EE90');
            grassGradient.addColorStop(1, '#228B22');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, 450, canvas.width, canvas.height - 450);

            // Small grass details
            ctx.strokeStyle = '#32CD32';
            ctx.lineWidth = 1;
            const grassPositions = [5, 15, 25, 35, 45, 55, 75, 85, 95, 105, 115, 125, 145, 155, 165, 175, 185, 195, 215, 225, 235, 245, 265, 275, 285, 295, 315, 325, 335, 345];
            grassPositions.forEach((offset, i) => {
                const x = offset + (i % 3) * 2;
                const y = 450 + (i % 2) * 3;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - 2 + (i % 2) * 4, y - 6);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x + 2, y);
                ctx.lineTo(x + (i % 2) * 4, y - 5);
                ctx.stroke();
            });
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID_WIDTH; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_HEIGHT; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
        }

        // Game logic
        function update() {
            if (!gameRunning) return;

            // Update direction
            direction = { ...nextDirection };

            // Move snake head
            const head = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            // Check wall collision
            if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                gameOver();
                return;
            }

            // Check self collision
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreElement.textContent = score;
                generateFood();
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    highScoreElement.textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }
            } else {
                snake.pop();
            }
        }

        function draw() {
            // Draw landscape background
            drawLandscape();

            // Draw grid overlay (semi-transparent)
            drawGrid();

            // Draw food
            drawFood();

            // Draw snake
            drawSnake();
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            finalScoreElement.textContent = score;
            gameOverElement.classList.add('show');
        }

        function startGame() {
            // Reset game state
            snake = [{ x: 10, y: 10 }];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            scoreElement.textContent = score;
            gameRunning = true;
            gameOverElement.classList.remove('show');
            
            generateFood();
            
            // Clear any existing game loop
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            
            // Start game loop
            gameLoop = setInterval(() => {
                update();
                draw();
            }, 150);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning && e.key.startsWith('Arrow')) {
                startGame();
                return;
            }

            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    }
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    }
                    break;
            }
        });

        // Initial draw
        draw();
        
        // Start game on first arrow key press or show instructions
        setTimeout(() => {
            if (!gameRunning) {
                gameOverElement.classList.remove('show');
            }
        }, 100);
    </script>
</body>
</html>
